{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to microBioRust","text":"<p>A blazing-fast, sustainable bioinformatics toolkit written in Rust \u2014 for microbial genomics rresearch, and optimised for functions used in data exploration.  </p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udd80 Built in Rust programming language for speed and safety</li> <li>\ud83d\udd04 Python bindings via pyo3 for InterOp - Rust meets Python</li> <li>\ud83d\udce6 Open source and community-driven</li> </ul>"},{"location":"#get-started","title":"Get Started!!","text":"<p>See Installation for details on how to install Rust for Linux, MacOSX and Windows Interested in microbiorust-py?  Check out the microbiorust-py section for quick-start &amp; more! </p> <p>Start a new project <code>cargo new microBioRust_test</code></p> <p>Add to your Cargo.toml <code>cargo add -p microBioRust</code></p> <p>to add the whole workspace including file parsing, sequence metrics, coming soon data viz (heatmap demonstration) and python bindings (microbiorust-py)</p> <p><code>cargo add -p seqmetrics</code> <code>cargo add -p heatmap</code> <code>cargo add -p microbiorust-py</code></p> <p>or clone the repo <code>git clone https://github.com/LCrossman/microBioRust.git</code></p> <p>Build the project <code>cargo build</code></p> <p>Run the tests <code>cargo test</code></p>"},{"location":"formats_and_parsing/","title":"Formats & Parsing","text":"<p>File types and Parsing behaviour</p> <p>Genbank (.gbk) &amp; Embl (.embl)</p> <ul> <li>We also provide the ability to convert these formats to gff3</li> </ul> <p>Each genome file is a basic text file following a specific ruleset and genbank (gbk) and embl are similar but differ in the required formatting.</p> <p>Structure and Parsing</p> <p>Top Level is the Records type. There is one Records type per genome file. Three types of macro have getters and setters for the data, these are SourceAttributes, FeatureAttributes, SequenceAttributes.</p> <p>The next level is the Record type. There may be one or many Record in a Records (up to ~ 2000 but more usually ~ 50). Each Record has a DNA sequence which is calculated on the fly by slicing the total sequence of Records with the start and stop coordinates. Each Record also has a SourceAttributes macro which stores ID, total start and stop of the Record sequence (different to the CDS features start and stop below). It also stores the Organism among some other database comments.</p> <p></p> <p>The full structure of the SourceAttributes, FeatureAttributes and SequenceAttributes is:</p> <p></p> <p>SourceAttributes stores the following in an enum:</p> <pre><code>pub enum SourceAttributes {\n    Start { value: RangeValue },\n    Stop { value: RangeValue },\n    Organism { value: String },\n    MolType { value: String},\n    Strain { value: String},\n    CultureCollection { value: String},\n    TypeMaterial { value: String},\n    DbXref { value:String}\n}\n</code></pre> <p>Where RangeValue can be either of:</p> <pre><code>RangeValue::Exact(value)\nRangeValue::LessThan(value) \nRangeValue::GreaterThan(value)\n</code></pre> <p>Most RangeValues are Exact(value) with exceptions usually at the start and end of sequences, indicating that they are truncated.</p> <p>Note that the start and stop of SourceAttributes relate to the sequence of the whole record</p> <p>Each Record can have None or many hundreds of coding sequences, CDS (stored in the FeatureAttributes). These are the predicted genes and contain annotation data per gene such as locus_tag (id), gene (may be empty), start, stop, strand (-1 or +1), codon start (1,2 or 3), product.</p> <p>FeatureAttributes stores the following in an enum:</p> <pre><code>pub enum FeatureAttributes {\n    Start { value: RangeValue },\n    Stop { value: RangeValue },\n    Gene { value: String },\n    Product { value: String },\n    CodonStart { value: u8 },\n    Strand { value: i8 },\n //   ec_number { value: String }\n}\n</code></pre> <p>currently EC_number is commented out but could be added back if there is demand</p> <p>Each CDS also has a DNA sequence .ffn (calculated on the fly from the start, stop and strand) and a protein sequence .faa (translated on the fly from the start, stop, strand and codon_start). The sequences are stored in the SequenceAttributes.</p> <p>SequenceAttributes stores the following in an enum:</p> <pre><code>pub enum SequenceAttributes {\n    Start { value: RangeValue },\n    Stop { value: RangeValue },\n    SequenceFfn { value: String },\n    SequenceFaa { value: String },\n    CodonStart { value: u8 },\n    Strand { value: i8 },\n}\n</code></pre> <p>Note the start, stop, strand and codon start of SequenceAttributes and FeatureAttributes are identical</p> <p>Sequences are stored separately in SequenceAttributes for efficiency. Although start, stop, locus_tag, and strand are duplicated in SequenceAttributes and FeatureAttributes, keeping them together may make it easier to slice the sequence and access the specific feature metadata at the same time.</p>"},{"location":"installation/","title":"Installation","text":"<p>How to Install</p> <p>Install Rust (recommended method):</p> <p>Please see here for base environment installation details for Rust programming language </p> <p>For MacOSX, Linux or other unix OS you can install Rust via:</p> <p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p> <p>For further details on Windows please see: other install</p> <p>Install with Conda: Disclaimer: While conda is a powerful package manager, it is primarily designed for managing Python environments, and the  Rust package available may not always be up-to-date or include all the necessary components</p> <p><code>conda install conda-forge::rust</code></p> <p>Install with Python for Rust with Python InterOp To use Python Interoperability you will need to install Python and additionally you may need (even if in a conda environment):</p> <p>For Linux: <code>export LD_LIBRARY_PATH=[directory where python is located]</code> </p> <p>For MacOSX:  <code>export DYLD_LIBRARY_PATH=[directory where python is located]</code></p> <p>For Windows please see this StackOverflow issue for a fix: fix here and please also see our specific windows_install page</p>"},{"location":"usage/","title":"Usage","text":"<p>In microBioRust:</p> <p>You can parse genbank files and save as a GFF (gff3) format as well as extracting DNA sequences, gene DNA sequences (ffn) and protein fasta sequences (faa) Super simple way:</p> <pre><code>pub fn genbank_to_faa() -&gt; Result&lt;(), anyhow::Error&gt; {\n    let args = Arguments::parse();\n    let records = genbank!(&amp;args.filename);\n    for record in records.iter() {\n        for (k, v) in &amp;record.cds.attributes {\n            if let Some(seq) = record.seq_features.get_sequence_faa(k) {\n                println!(\"&gt;{}|{}\\n{}\", &amp;record.id, &amp;k, seq);\n            }\n        }\n    }\n    return Ok(());\n}\n\n</code></pre> <p>Better for Debugging:</p> <pre><code>pub fn genbank_to_faa() -&gt; Result&lt;(), anyhow::Error&gt; {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let config = Config::new(&amp;args).unwrap_or_else(|err| {\n        println!(\"Problem with parsing file arguments: {}\", err);\n        process::exit(1);\n    });\n    let file_gbk = fs::File::open(config.filename)?;\n    let mut reader = Reader::new(file_gbk);\n    let mut records = reader.records();\n    let mut cds_counter: u32 = 0;\n    loop {\n        //collect from each record advancing on a next record basis, count cds records\n        match records.next() {\n            Some(Ok(mut record)) =&gt; {\n                for (k, v) in &amp;record.cds.attributes {\n                    match record.seq_features.get_sequence_faa(&amp;k) {\n                        Some(value) =&gt; {\n                            let seq_faa = value.to_string();\n                            println!(\"&gt;{}|{}\\n{}\", &amp;record.id, &amp;k, seq_faa);\n                        }\n                        _ =&gt; (),\n                    };\n                }\n                cds_counter += 1;\n            }\n            Some(Err(e)) =&gt; {\n                println!(\"Error encountered - an err {:?}\", e);\n            }\n            None =&gt; {\n                println!(\"finished iteration\");\n                break;\n            }\n        }\n    }\n    println!(\"Total records processed: {}\", read_counter);\n    return Ok(());\n}\n</code></pre> <p>Example to save a provided multi- or single genbank file as a GFF file (by joining any multi-genbank)</p> <pre><code>pub fn genbank_to_gff() -&gt; io::Result&lt;()&gt; {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let config = Config::new(&amp;args).unwrap_or_else(|err| {\n        println!(\"Problem with parsing file arguments: {}\", err);\n        process::exit(1);\n        });\n    let file_gbk = fs::File::open(&amp;config.filename)?;\n    let prev_start: u32 = 0;\n    let mut prev_end: u32 = 0;\n    let mut reader = Reader::new(file_gbk);\n    let mut records = reader.records();\n    let mut read_counter: u32 = 0;\n    let mut seq_region: BTreeMap&lt;String, (u32,u32)&gt; = BTreeMap::new();\n    let mut record_vec: Vec&lt;Record&gt; = Vec::new();\n    loop {  \n        match records.next() {   \n            Some(Ok(mut record)) =&gt; {\n                //println!(\"next record\");\n                //println!(\"Record id: {:?}\", record.id);\n                let source = record.source_map.source_name.clone().expect(\"issue collecting source name\");\n                let beginning = match record.source_map.get_start(&amp;source) {\n                                    Some(value) =&gt; value.get_value(),\n                                    _ =&gt; 0,\n                                    };\n                let ending = match record.source_map.get_stop(&amp;source) {\n                                    Some(value) =&gt; value.get_value(),\n                                    _ =&gt; 0,\n                                    };\n                if ending + prev_end &lt; beginning + prev_end {\n                    }\n                seq_region.insert(source, (beginning + prev_end, ending + prev_end));\n                record_vec.push(record);\n                // Add additional fields to print if needed\n                read_counter+=1;\n                prev_end+=ending; // create the joined record if there are multiple\n                },\n            Some(Err(e)) =&gt; { println!(\"theres an err {:?}\", e); },\n                None =&gt; {\n                println!(\"finished iteration\");\n                        break; },\n            }\n        }\n    let output_file = format!(\"{}.gff\", &amp;config.filename);\n    gff_write(seq_region.clone(), record_vec, &amp;output_file, true);\n    println!(\"Total records processed: {}\", read_counter);\n    return Ok(());\n}\n</code></pre> <p>Example to create a completely new record, use of setters or set_ functionality</p> <p>To write into GFF format requires gff_write(seq_region, record_vec, filename, true or false)</p> <p>The seq_region is the region of interest to save with name and DNA coordinates such as <code>seqregion.entry(\"source_1\".to_string(), (1,897))</code></p> <p>This makes it possible to save the whole file or to subset it</p> <p>record_vec is a list of the records.  If there is only one record, include this as a vec using <code>vec![record]</code></p> <p>The boolean true/false describes whether the DNA sequence should be included in the GFF3 file</p> <p>To write into genbank format requires gbk_write(seq_region, record_vec, filename), no true or false since genbank format will include the DNA sequence</p> <p><code>rust pub fn create_new_record() -&gt; Result&lt;(), anyhow::Error&gt; {     let filename = format!(\"new_record.gff\");     let mut record = Record::new();     let mut seq_region: BTreeMap&lt;String, (u32, u32)&gt; = BTreeMap::new();     //example from E.coli K12     seq_region.insert(\"source_1\".to_string(), (1, 897));     //Add the source into SourceAttributes     record         .source_map         .set_counter(\"source_1\".to_string())         .set_start(RangeValue::Exact(1))         .set_stop(RangeValue::Exact(897))         .set_organism(\"Escherichia coli\".to_string())         .set_mol_type(\"DNA\".to_string())         .set_strain(\"K-12 substr. MG1655\".to_string())         .set_type_material(\"type strain of Escherichia coli K12\".to_string())         .set_db_xref(\"PRJNA57779\".to_string());     //Add the features into FeatureAttributes, here we are setting two features, i.e. coding sequences or genes     record         .cds         .set_counter(\"b3304\".to_string())         .set_start(RangeValue::Exact(1))         .set_stop(RangeValue::Exact(354))         .set_gene(\"rplR\".to_string())         .set_product(\"50S ribosomal subunit protein L18\".to_string())         .set_codon_start(1)         .set_strand(-1);     record         .cds         .set_counter(\"b3305\".to_string())         .set_start(RangeValue::Exact(364))         .set_stop(RangeValue::Exact(897))         .set_gene(\"rplF\".to_string())         .set_product(\"50S ribosomal subunit protein L6\".to_string())         .set_codon_start(1)         .set_strand(-1);     //Add the sequences for the coding sequence (CDS) into SequenceAttributes     record         .seq_features         .set_counter(\"b3304\".to_string())         .set_start(RangeValue::Exact(1))         .set_stop(RangeValue::Exact(354))         .set_sequence_ffn(             \"ATGGATAAGAAATCTGCTCGTATCCGTCGTGCGACCCGCGCACGCCGCAAGCTCCAGGAG CTGGGCGCAACTCGCCTGGTGGTACATCGTACCCCGCGTCACATTTACGCACAGGTAATT GCACCGAACGGTTCTGAAGTTCTGGTAGCTGCTTCTACTGTAGAAAAAGCTATCGCTGAA CAACTGAAGTACACCGGTAACAAAGACGCGGCTGCAGCTGTGGGTAAAGCTGTCGCTGAA CGCGCTCTGGAAAAAGGCATCAAAGATGTATCCTTTGACCGTTCCGGGTTCCAATATCAT GGTCGTGTCCAGGCACTGGCAGATGCTGCCCGTGAAGCTGGCCTTCAGTTCTAA\"                 .to_string(),         )         .set_sequence_faa(             \"MDKKSARIRRATRARRKLQELGATRLVVHRTPRHIYAQVIAPNGSEVLVAASTVEKAIAE QLKYTGNKDAAAAVGKAVAERALEKGIKDVSFDRSGFQYHGRVQALADAAREAGLQF\"                 .to_string(),         )         .set_codon_start(1)         .set_strand(-1);     record         .seq_features         .set_counter(\"bb3305\".to_string())         .set_start(RangeValue::Exact(364))         .set_stop(RangeValue::Exact(897))         .set_sequence_ffn(             \"ATGTCTCGTGTTGCTAAAGCACCGGTCGTTGTTCCTGCCGGCGTTGACGTAAAAATCAAC GGTCAGGTTATTACGATCAAAGGTAAAAACGGCGAGCTGACTCGTACTCTCAACGATGCT GTTGAAGTTAAACATGCAGATAATACCCTGACCTTCGGTCCGCGTGATGGTTACGCAGAC GGTTGGGCACAGGCTGGTACCGCGCGTGCCCTGCTGAACTCAATGGTTATCGGTGTTACC GAAGGCTTCACTAAGAAGCTGCAGCTGGTTGGTGTAGGTTACCGTGCAGCGGTTAAAGGC AATGTGATTAACCTGTCTCTGGGTTTCTCTCATCCTGTTGACCATCAGCTGCCTGCGGGT ATCACTGCTGAATGTCCGACTCAGACTGAAATCGTGCTGAAAGGCGCTGATAAGCAGGTG ATCGGCCAGGTTGCAGCGGATCTGCGCGCCTACCGTCGTCCTGAGCCTTATAAAGGCAAG GGTGTTCGTTACGCCGACGAAGTCGTGCGTACCAAAGAGGCTAAGAAGAAGTAA\"                 .to_string(),         )         .set_sequence_faa(             \"MSRVAKAPVVVPAGVDVKINGQVITIKGKNGELTRTLNDAVEVKHADNTLTFGPRDGYAD GWAQAGTARALLNSMVIGVTEGFTKKLQLVGVGYRAAVKGNVINLSLGFSHPVDHQLPAG ITAECPTQTEIVLKGADKQVIGQVAADLRAYRRPEPYKGKGVRYADEVVRTKEAKKK\"                 .to_string(),         )         .set_codon_start(1)         .set_strand(-1);     //Add the full sequence of the entire record into the record.sequence     record.sequence = \"TTAGAACTGAAGGCCAGCTTCACGGGCAGCATCTGCCAGTGCCTGGACACGACCATGATA TTGGAACCCGGAACGGTCAAAGGATACATCTTTGATGCCTTTTTCCAGAGCGCGTTCAGC GACAGCTTTACCCACAGCTGCAGCCGCGTCTTTGTTACCGGTGTACTTCAGTTGTTCAGC GATAGCTTTTTCTACAGTAGAAGCAGCTACCAGAACTTCAGAACCGTTCGGTGCAATTAC CTGTGCGTAAATGTGACGCGGGGTACGATGTACCACCAGGCGAGTTGCGCCCAGCTCCTG GAGCTTGCGGCGTGCGCGGGTCGCACGACGGATACGAGCAGATTTCTTATCCATAGTGTT ACCTTACTTCTTCTTAGCCTCTTTGGTACGCACGACTTCGTCGGCGTAACGAACACCCTT GCCTTTATAAGGCTCAGGACGACGGTAGGCGCGCAGATCCGCTGCAACCTGGCCGATCAC CTGCTTATCAGCGCCTTTCAGCACGATTTCAGTCTGAGTCGGACATTCAGCAGTGATACC CGCAGGCAGCTGATGGTCAACAGGATGAGAGAAACCCAGAGACAGGTTAATCACATTGCC TTTAACCGCTGCACGGTAACCTACACCAACCAGCTGCAGCTTCTTAGTGAAGCCTTCGGT AACACCGATAACCATTGAGTTCAGCAGGGCACGCGCGGTACCAGCCTGTGCCCAACCGTC TGCGTAACCATCACGCGGACCGAAGGTCAGGGTATTATCTGCATGTTTAACTTCAACAGC ATCGTTGAGAGTACGAGTCAGCTCGCCGTTTTTACCTTTGATCGTAATAACCTGACCGTT GATTTTTACGTCAACGCCGGCAGGAACAACGACCGGTGCTTTAGCAACACGAGACAT\"         .to_string();     gff_write(seq_region, vec![record], &amp;filename, true);     return Ok(()); }</code></p>"},{"location":"windows_install/","title":"Installation on Windows","text":"<p>   Author: Sreeram Peela</p> <p>Pre-requisites</p> <p>Rust is the programming language of choice for complex tasks these days. Installing microBioRust in windows requires Rust to be installed and the PATH variables to be added.  </p> <p>We recommend installing Rust (and microBioRust) using Windows Powershell (logged as admin).  </p> <p>Alternately, the latest executables for GUI-based installation can be found here: https://www.rust-lang.org/tools/install</p> <ol> <li>Navigate to the directory of your choice and open Powershell in admin mode.</li> <li>Download Rust executable from Powershell using the command:  </li> </ol> <pre><code>Invoke-WebRequest\n-Uri https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe\n-OutFile rustup-init.exe\n# Run the below command to start installation\n.\\rustup-init.exe```\n\n</code></pre> <p> Installing Rust typically can be made through Visual Studio Community installer (Select option 1 when prompted). This documentation is written by selecting this option  </p> <p>Installation VS community installer requires downloading additional packages - Win11_SDK and .. Please note that both these require almost 6GB of memory !!  </p> <ol> <li>Select \u2018Default installation\u2019 when prompted.  </li> <li>After a typical installation is over, close the powershell and reopen it to make changes in the PATH.  </li> </ol> <p># Check if installation is successful </p> <pre><code>cargo help\n</code></pre> <p>For a successful installation, the above command will display different options and subcommands in Cargo. We will be using this for installing microBioRust (or any Rust package).</p> <p>Install microBioRust </p> <p>The microBioRust repo is being hosted on GitHub here. We recommend using Git for smooth installation. Alternatively, users can download the repo as a ZIP file, uncompress it (with your own choice of tools), and navigate to the directory.  </p> <p># Clone the repo using Git </p> <pre><code>git clone https://github.com/LCrossman/microBioRust.git  \n</code></pre> <p># Navigate to the dir </p> <pre><code>cd microBioRust\n</code></pre> <p>Inside the directory, one can use Cargo to build the library.  </p> <pre><code># Inside the project directory\ncargo build\n</code></pre> <p> The above command downloads and installs necessary dependencies for smooth functioning of the package. Please wait until all the required dependencies are installed and compilation for microBioRust is completed.  </p> <p>Once the package has been built, it is a general practise to test whether installation was successful.  For testing the installation, run the command:  </p> <pre><code># test installation of the package  \ncargo test\n</code></pre> <p>The above test instance runs over multiple files packed with the repo, and a final output message can help us in understanding errors. Typically, successful installation gives the following last few lines:  </p> <p></p> <p>Congratulations!! You have successfully installed microBioRust in your system. You can proceed with Getting started section of the documentation.  </p> <p>Session Information:  </p> <p> </p>"}]}